<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Life-is-Green</title>
  <meta name="viewport" content="width=device-width, height=device-height,
    user-scalable=no, initial-scale=1, maximum-scale=1" />
  <script src="https://unpkg.com/sounds-some-sounds@1.0.5/build/index.js"></script>
  <script src="https://unpkg.com/gif-capture-canvas@1.1.0/build/index.js"></script>
  <script src="https://unpkg.com/terser@4.6.11/dist/bundle.min.js"></script>
  <script src="https://unpkg.com/pixi.js@5.3.0/dist/pixi.min.js"></script>
  <script src="https://unpkg.com/pixi-filters@3.1.1/dist/pixi-filters.js"></script>
  <script>
    var module = {};
  </script>
  <script src="https://unpkg.com/lodash.clonedeep@4.5.0/index.js"></script>
  <script src="https://abagames.github.io/crisp-game-lib/bundle.js"></script>

  <script>
    title = "Life is Green";

    description = `
[Push] cross line
`;

    characters = [
      `
BbBbB
BBBBB
BlBlB
lBBBl
l   l
`,



    ];

    options = {
      viewSize: { x: 120, y: 120 },
      isPlayingBgm: true,
      isReplayEnabled: true,
      seed: 9,
      isDrawingScoreFront: true,
      theme: "shape",
    };
    var playerPos = vec(11, 10);
    var inAreaMovement = vec(0, 0);
    var undyingtime = true;

    const enemys = [];

    const greens = [];
    var isinGreen = false;
    var newGreen = vec(0, 0);

    var points = 0;
    function update() {

      if (!ticks) {
        isinGreen = false;
        newGreen = vec(0, 0);
        playerPos = vec(11, 10);
        inAreaMovement = vec(0, 0);
        points = 0;
        enemys.length = 0;

        for (var i = 0; i < 4; i++) {
          var ang = rndi(10, 350);
          const s = {
            pos: vec(55, 55),
            angle: ang,
          }
          enemys.push(s);
        }
        greens.length = 0;
        for (var i = 0; i < 6; i++) {
          greens.push(vec(rndi(20, 100), rndi(20, 100)));
        }
      }



      //greens
      color("green");
      var greenNum = 1;
      var isAddEnemy = false;
      greens.forEach(e => {
        arc(e.x, e.y, 2);
        arc(e.x, e.y, 5);
        arc(e.x, e.y, 8);
        if (abs(e.x - newGreen.x) <= 16 && abs(e.y - newGreen.y) <= 16) {
          if (greens.length != greenNum && !isAddEnemy) {
            play("jump");
            var ang = rndi(190, 260);
            const s = {
              pos: vec(abs(e.x + newGreen.x) / 2, abs(e.y + newGreen.y) / 2),
              angle: ang,
            }
            enemys.push(s);
            isAddEnemy = true;
          }
        }
        greenNum++;
      })
      newGreen = vec(500, 500);

      //stage
      color("light_yellow");
      line(9, 9, 111, 9);
      line(9, 9, 9, 111);
      line(111, 111, 111, 9);
      line(111, 111, 9, 111);

      //player
      if (playerPos.y >= 110) {
        playerPos.x += 1;
        inAreaMovement = vec(0, 0);
      } else if (playerPos.y <= 10) {
        playerPos.x -= 1;
        inAreaMovement = vec(0, 0);
      }
      if (playerPos.x >= 110) {
        playerPos.y -= 1;
        inAreaMovement = vec(0, 0);
      } else if (playerPos.x <= 10) {
        playerPos.y += 1;
        inAreaMovement = vec(0, 0);
      }
      if (input.isJustPressed) {
        if (playerPos.y >= 110) {
          inAreaMovement.y = -1;
        } else if (playerPos.y <= 10) {
          inAreaMovement.y = 1;
        } else if (playerPos.x >= 110) {
          inAreaMovement.x = -1;
        } else if (playerPos.x <= 10) {
          inAreaMovement.x = 1;
        }
      }
      playerPos.x += inAreaMovement.x;
      playerPos.y += inAreaMovement.y;
      color("black");
      if (undyingtime) color("light_blue");

      if (char("a", playerPos.x, playerPos.y).isColliding.rect.green) {
        isinGreen = true;
        points++;
      } else {
        if (points) {
          addScore(points, playerPos);
          play("coin");
          points = 0;
          isinGreen = false;
        }
      }

      //enemy

      color("red");

      enemys.forEach(e => {
        //enemy movement
        if (e.pos.x <= 10) {
          e.angle = 180 - e.angle;
        } else if (e.pos.x >= 110) {
          e.angle = 180 - e.angle;
        }
        if (e.pos.y <= 10) {
          e.angle = 360 - e.angle;
        } else if (e.pos.y >= 110) {
          e.angle = 360 - e.angle;
        }

        e.pos.addWithAngle(e.angle * PI / 180, 0.5 + score / 2000);

        //enemy collision
        if (box(e.pos.x, e.pos.y, 3, 3).isColliding.char.a) {
          if (undyingtime) {

          } else if (!isinGreen) {
            play("hit");
            greens.push(vec(e.pos.x, e.pos.y));
            newGreen = vec(e.pos.x, e.pos.y);
            playerPos = vec(11, 10);
            ticks = 1;
            undyingtime = true;
          } else if (!undyingtime) {
            play("explosion");
            end();
          }
        }
      })
      if (ticks >= 60) {
        undyingtime = false;
      }

    }

    addEventListener("load", onLoad);
  </script>

</head>

<body style="background: #ddd"></body>

</html>